/* Thu Nov  7 20:10:54 2019 */
/* cosi_builtins.js */
" /* \n " 
" MIT License \n " 
"  \n " 
" Cosi (Javascript Native Runtime) \n " 
"  \n " 
" Copyright (c) 2019 Sebastian Garth \n " 
"  \n " 
" Permission is hereby granted, free of charge, to any person obt \n " 
" aining a copy \n " 
" of this software and associated documentation files (the \"Softw \n " 
" are\"), to deal \n " 
" in the Software without restriction, including without limitati \n " 
" on the rights \n " 
" to use, copy, modify, merge, publish, distribute, sublicense, a \n " 
" nd/or sell \n " 
" copies of the Software, and to permit persons to whom the Softw \n " 
" are is \n " 
" furnished to do so, subject to the following conditions: \n " 
"  \n " 
" The above copyright notice and this permission notice shall be  \n " 
" included in all \n " 
" copies or substantial portions of the Software. \n " 
"  \n " 
" THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \n " 
"  EXPRESS OR \n " 
" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHAN \n " 
" TABILITY, \n " 
" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVE \n " 
" NT SHALL THE \n " 
" AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES O \n " 
" R OTHER \n " 
" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, \n " 
"  ARISING FROM, \n " 
" OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER D \n " 
" EALINGS IN THE \n " 
" SOFTWARE. \n " 
" */ \n " 
"  \n " 
" /* \n " 
"  Imports \n " 
" */ \n " 
"  \n " 
" var imports = {} \n " 
"  \n " 
" /* \n " 
"  Utilities \n " 
" */ \n " 
"  \n " 
" function egress(exception) \n " 
" {  \n " 
"  if(exception) \n " 
"   throw exception \n " 
"  if(!(this instanceof egress)) \n " 
"   egress(new egress())  \n " 
" } \n " 
"  \n " 
" function verify(object, exception) \n " 
" { \n " 
"  if(!object) \n " 
"   egress(exception) \n " 
" } \n " 
"  \n " 
" function fail(condition, exception) \n " 
" { \n " 
"  verify(!condition, exception)  \n " 
" } \n " 
"  \n " 
" function caught(routine, handler) \n " 
" { \n " 
"  try \n " 
"  { \n " 
"   routine() \n " 
"   return undefined \n " 
"  } \n " 
"  catch(exception) \n " 
"  { \n " 
"   if(handler) \n " 
"    handler(exception) \n " 
"   return exception \n " 
"  } \n " 
" } \n " 
"  \n " 
" function contain(routine, handler) \n " 
" { \n " 
"  var  \n " 
"   exception = caught(routine, handler) \n " 
"  if(exception) \n " 
"   print(\"Error:\", exception) \n " 
"  return exception \n " 
" } \n " 
"  \n " 
" function escape(routine, handler) \n " 
" { \n " 
"  try \n " 
"  { \n " 
"   routine() \n " 
"   return false \n " 
"  } \n " 
"  catch(exception) \n " 
"  { \n " 
"   if(exception instanceof egress) \n " 
"    return true \n " 
"   if(handler) \n " 
"    handler(exception) \n " 
"   egress(exception)  \n " 
"  } \n " 
" } \n " 
"  \n " 
" function loop(control, action) \n " 
" { \n " 
"  if(!control) \n " 
"   return \n " 
"  if(control === true) \n " 
"   control = Infinity \n " 
"  var \n " 
"   result, \n " 
"   count = control.length ||  \n " 
"    control.end || control.finish ||  \n " 
"    control, \n " 
"   start = control.begin  \n " 
"    || control.start || 0 \n " 
"  escape(function(){ \n " 
"   for(var idx = start; idx < count; ++idx) \n " 
"   { \n " 
"    result = action(idx, control) \n " 
"    if(result !== undefined) \n " 
"     break \n " 
"   } \n " 
"  }) \n " 
"  return result \n " 
" } \n " 
"  \n " 
" /* \n " 
"  https://stackoverflow.com/questions/5515869/string-length-in-b \n " 
" ytes-in-javascript \n " 
" */ \n " 
"  \n " 
" function utf_strlen(text) \n " 
" { \n " 
"  if(text > 0) \n " 
"   text = bytes_to_text(text) \n " 
"  var length = text.length \n " 
"  var extras = text.match(/%[89ABab]/g); \n " 
"  if(extras) \n " 
"   length += extras.length \n " 
"  return length \n " 
" } \n " 
"  \n " 
" /* \n " 
"  Common conversions \n " 
" */ \n " 
" function file_to_bytes(source) \n " 
" { \n " 
"  var  \n " 
"   fp = NULL, \n " 
"   length = 0, \n " 
"   data = NULL, \n " 
"   packed = source.file, \n " 
"   file = packed || source, \n " 
"   error = caught(function(){  \n " 
"    fp = fopen(file, 'rb') \n " 
"    verify(fp) \n " 
"    fseek(fp, 0, SEEK_END) \n " 
"    length = ftell(fp) \n " 
"    rewind(fp) \n " 
"    data = malloc(length + 1) \n " 
"    verify(data) \n " 
"    verify(length == fread(data, 1, length, fp)) \n " 
"    set_byte(data, length, 0) \n " 
"    if(packed) \n " 
"    {  \n " 
"     source.length = length \n " 
"     source.bytes = data \n " 
"     data = source \n " 
"    } \n " 
"   }) \n " 
"  if(error) \n " 
"  { \n " 
"   free(data) \n " 
"   data = NULL \n " 
"  } \n " 
"  if(fp) \n " 
"   fclose(fp) \n " 
"  return data \n " 
" } \n " 
"  \n " 
" function bytes_to_file(bytes, file, len) \n " 
" { \n " 
"  if(bytes == NULL) \n " 
"   return false \n " 
"  var out = file \n " 
"  if(!(file > 0)) \n " 
"   out = fopen(file, 'wb+') \n " 
"  if(!len) \n " 
"   len = utf_strlen(bytes) \n " 
"  var pass = false \n " 
"  if(out) \n " 
"  { \n " 
"   if(fwrite(bytes, 1, len, out) == len) \n " 
"    pass = true \n " 
"   fclose(out) \n " 
"  } \n " 
"  return pass \n " 
" } \n " 
"  \n " 
" function file_to_text(file) \n " 
" { \n " 
"  var source = file_to_bytes({ file : file }) \n " 
"  if(source == NULL) \n " 
"   return null \n " 
"  var  \n " 
"   bytes = source.bytes, \n " 
"   result = bytes_to_text(bytes, source.length) \n " 
"  free(bytes) \n " 
"  return result \n " 
" } \n " 
"  \n " 
" function text_to_file(text, file) \n " 
" { \n " 
"  var data = text_to_bytes(text) \n " 
"  var pass = bytes_to_file(data, file, utf_strlen(data)) \n " 
"  free(data) \n " 
"  return pass \n " 
" } \n " 
"  \n " 
" /* \n " 
"  Conversions to Javascript objects \n " 
" */ \n " 
" function text_to_function(script, imports) \n " 
" { \n " 
"  if(!script) \n " 
"   return null \n " 
"  var result = null \n " 
"  escape(function(){ \n " 
"   var bundled =  \n " 
"    'return function(){' +  \n " 
"    ' var module = { exports : null };' + \n " 
"    ' var exports = (function(){' + \n " 
"    script +  \n " 
"    '})(); return exports ? exports : module.exports }' \n " 
"   var invoke = new Function('imports', bundled) \n " 
"   result = invoke(imports) \n " 
"  }) \n " 
"  return result \n " 
" } \n " 
"  \n " 
" function text_to_task(script, imports) \n " 
" { \n " 
"  var loaded = text_to_function(script, imports); \n " 
"  if(loaded) \n " 
"   loaded() \n " 
"  else \n " 
"   return false \n " 
"  return true \n " 
" } \n " 
"  \n " 
" function text_to_module(script, imports) \n " 
" { \n " 
"  var loaded = text_to_function(script, imports); \n " 
"  return loaded ? loaded() : null \n " 
" } \n " 
"  \n " 
" function text_to_object(script, imports) \n " 
" { \n " 
"  return text_to_module('return ' + script, imports) \n " 
" } \n " 
"  \n " 
" function file_to_function(script, imports) \n " 
" { \n " 
"  return text_to_function(file_to_text(file), imports) \n " 
" } \n " 
"  \n " 
" function file_to_task(file, imports) \n " 
" { \n " 
"  return text_to_task(file_to_text(file), imports) \n " 
" } \n " 
"  \n " 
" function file_to_module(file, imports) \n " 
" { \n " 
"  return text_to_module(file_to_text(file), imports) \n " 
" } \n " 
"  \n " 
" function file_to_object(file) \n " 
" { \n " 
"  return text_to_object(file_to_text(file), imports) \n " 
" } \n " 
"  \n " 
" /* \n " 
"  Input and output \n " 
" */ \n " 
"  \n " 
" function log_display(stream) \n " 
" { \n " 
"  var args = arguments \n " 
"  var first = 1 \n " 
"  for(var index = first; index < args.length; ++index) \n " 
"  { \n " 
"   if(index > first) \n " 
"    clog(stream, ' ') \n " 
"   var arg = args[index]; \n " 
"   if(arg === null) \n " 
"    arg = '(null)' \n " 
"   else if(arg === undefined) \n " 
"    arg = '(undefined)' \n " 
"   clog(stream, arg.toString()) \n " 
"  } \n " 
" } \n " 
"  \n " 
" function log_print() \n " 
" { \n " 
"  log_display.apply(null, arguments) \n " 
"  putchar(0xa) \n " 
" } \n " 
"  \n " 
" function display() \n " 
" { \n " 
"  [].unshift.call(arguments, stdout) \n " 
"  log_display.apply(null, arguments) \n " 
" } \n " 
"  \n " 
" function print() \n " 
" { \n " 
"  [].unshift.call(arguments, stdout) \n " 
"  log_print.apply(null, arguments) \n " 
" } \n " 
"  \n " 
" function read_line(stream) \n " 
" { \n " 
"  var sum = 0 \n " 
"  var size = 64 \n " 
"  var data = NULL \n " 
"  var newline = 0xa \n " 
"  if(!stream) \n " 
"   stream = stdin \n " 
"  var pass = loop(true, function() { \n " 
"   var  \n " 
"    max = size \n " 
"   size *= 2 \n " 
"   var block = realloc(data, size + 1) \n " 
"   if(block == NULL) \n " 
"    return false \n " 
"   data = block \n " 
"   var  \n " 
"    line = data + sum \n " 
"   if(!fgets(line, max, stream)) \n " 
"    return sum != 0 \n " 
"   var  \n " 
"    length = utf_strlen(line), \n " 
"    last = length - 1  \n " 
"   if(get_byte(line, last) == newline)  \n " 
"    set_byte(line, last--, 0) \n " 
"   sum += (last + 1) \n " 
"   if(length != max) \n " 
"    return true \n " 
"  }) \n " 
"  if(!pass) \n " 
"  { \n " 
"   free(data) \n " 
"   return null  \n " 
"  } \n " 
"  return bytes_to_text(data)   \n " 
" } \n " 
"  \n " 
" function prompt() \n " 
" { \n " 
"  display.apply(null, arguments) \n " 
"  clog(stdout, ' ') \n " 
"  return read_line() \n " 
" } \n " 
"  \n " 
" function script_arguments(skip_first) \n " 
" { \n " 
"  var args = argv() \n " 
"  if(args == NULL) \n " 
"   return null \n " 
"  var tab = [] \n " 
"  if(get_memory(args) == NULL) \n " 
"   return tab \n " 
"  var align = sizeof('void*') \n " 
"  if(skip_first !== false) \n " 
"   args += align \n " 
"  for(;;) \n " 
"  { \n " 
"   var ptr = get_memory(args) \n " 
"   if(ptr == NULL) \n " 
"    break \n " 
"   tab.push(bytes_to_text(ptr)) \n " 
"   args += align \n " 
"  } \n " 
"  return tab \n " 
" } \n " 
"  \n " 
" function script_environment() \n " 
" { \n " 
"  var args = envp() \n " 
"  var tab = [] \n " 
"  if(args == NULL) \n " 
"   return null \n " 
"  var align = sizeof('void*') \n " 
"  for(;;) \n " 
"  { \n " 
"   var ptr = get_memory(args) \n " 
"   if(ptr == NULL) \n " 
"    break \n " 
"   tab.push(bytes_to_text(ptr)) \n " 
"   args += align \n " 
"  } \n " 
"  return tab \n " 
" } \n " 
"  \n " 
" function script_path() \n " 
" { \n " 
"  var args = argv() \n " 
"  if(!args) \n " 
"   return null \n " 
"  return bytes_to_text(get_memory(args)) \n " 
" } \n " 
"  \n " 
" function process_directory(directory, callback) \n " 
" { \n " 
"  var enter = callback.enter \n " 
"  var process = callback.process || callback \n " 
"  var leave = callback.leave \n " 
"  var saved = current_directory() \n " 
"  var handle = opendir(directory) \n " 
"  if(handle != NULL) \n " 
"  { \n " 
"   if(enter) \n " 
"    enter(directory) \n " 
"   chdir(directory) \n " 
"   while(true) \n " 
"   { \n " 
"    var info = readdir(handle) \n " 
"    if(info == NULL) \n " 
"     break \n " 
"    var path = dirent_name(info) \n " 
"    if(path == \".\" || path == \"..\") \n " 
"     continue \n " 
"    var type = dirent_type(info) \n " 
"    if(type & DT_DIR) \n " 
"     process_directory(path, callback) \n " 
"    else \n " 
"     process(path, type)  \n " 
"   }  \n " 
"   if(leave) \n " 
"    leave(directory) \n " 
"   closedir(handle) \n " 
"  } \n " 
"  chdir(saved) \n " 
" } \n " 
"  \n " 
" function text_to_array(text) \n " 
" { \n " 
"  var arr = [] \n " 
"  for(var tdx = 0, len = text.length; tdx < len; ++tdx) \n " 
"   arr.push(text.charCodeAt(tdx))   \n " 
"  return arr \n " 
" } \n " 
"  \n " 
" function array_to_text(array) \n " 
" {  \n " 
"  var txt = \"\" \n " 
"  for(var tdx = 0, len = array.length; tdx < len; ++tdx) \n " 
"   txt += String.fromCharCode(array[tdx])   \n " 
"  return txt \n " 
" } \n " 
"  \n " 
