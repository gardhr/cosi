/* Tue Dec 17 12:01:00 2019 */
/* builtins.js */
" /* \n "
" MIT License \n "
"  \n "
" Cosi (Javascript Native Runtime) \n "
"  \n "
" Copyright (c) 2019 Sebastian Garth \n "
"  \n "
" Permission is hereby granted, free of charge, to any person obtaining a copy \n "
" of this software and associated documentation files (the \"Software\"), to deal \n "
" in the Software without restriction, including without limitation the rights \n "
" to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \n "
" copies of the Software, and to permit persons to whom the Software is \n "
" furnished to do so, subject to the following conditions: \n "
"  \n "
" The above copyright notice and this permission notice shall be included in all \n "
" copies or substantial portions of the Software. \n "
"  \n "
" THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n "
" IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n "
" FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n "
" AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n "
" LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n "
" OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n "
" SOFTWARE. \n "
" */ \n "
"  \n "
" /* \n "
"  Imports \n "
" */ \n "
"  \n "
" var imports = {} \n "
"  \n "
" /* \n "
"  Utilities \n "
" */ \n "
"  \n "
" function char(text, index) \n "
" {  \n "
"  return text.charCodeAt(index | 0) \n "
" } \n "
"  \n "
" function text(code) \n "
" {  \n "
"  return String.fromCharCode(code) \n "
" } \n "
"  \n "
" function text_to_array(text) \n "
" { \n "
"  var arr = [] \n "
"  for(var tdx = 0, len = text.length; tdx < len; ++tdx) \n "
"   arr.push(char(text, tdx))   \n "
"  return arr \n "
" } \n "
"  \n "
" function array_to_text(array) \n "
" {  \n "
"  var txt = \"\" \n "
"  for(var tdx = 0, len = array.length; tdx < len; ++tdx)  txt += text(array[tdx])   \n "
"  return txt \n "
" } \n "
"  \n "
" function escape(exception) \n "
" {  \n "
"  if(exception) \n "
"   throw exception \n "
"  if(!(this instanceof escape)) \n "
"   escape(new escape()) } \n "
"  \n "
" function verify(object, exception) \n "
" { \n "
"  if(!object) \n "
"   escape(exception) \n "
" } \n "
"  \n "
" function fail(condition, exception) \n "
" { \n "
"  verify(!condition, exception)  \n "
" } \n "
"  \n "
" function caught(routine, handler) \n "
" { \n "
"  try \n "
"  { \n "
"   routine() \n "
"   return undefined \n "
"  } \n "
"  catch(exception) \n "
"  { \n "
"   if(handler) \n "
"    handler(exception) \n "
"   return exception \n "
"  } \n "
" } \n "
"  \n "
" function contain(routine, handler) \n "
" { \n "
"  var  \n "
"   exception = caught(routine, handler) \n "
"  if(exception) \n "
"  { \n "
"   print(\"Error:\", exception) \n "
"   var est = exception.stackTrace \n "
"   if(est) \n "
"    print(est) \n "
"  } \n "
"  return exception \n "
" } \n "
"  \n "
" function escaped(routine, handler) \n "
" { \n "
"  try \n "
"  { \n "
"   routine() \n "
"   return false \n "
"  } \n "
"  catch(exception) \n "
"  { \n "
"   if(exception instanceof escape) \n "
"    return true \n "
"   if(handler) \n "
"    handler(exception) \n "
"   escape(exception)  \n "
"  } \n "
" } \n "
"  \n "
" function loop(control, action) \n "
" { \n "
"  if(!control) \n "
"   return \n "
"  if(control === true) \n "
"   control = Infinity \n "
"  var \n "
"   result, \n "
"   count = control.length ||  \n "
"    control.end || control.finish ||  \n "
"    control, \n "
"   start = control.begin  \n "
"    || control.start || 0 \n "
"  escaped(function(){ \n "
"   for(var idx = start; idx < count; ++idx) \n "
"   { \n "
"    result = action(idx, control) \n "
"    if(result !== undefined) \n "
"     break \n "
"   } \n "
"  }) \n "
"  return result \n "
" } \n "
"  \n "
" /* https://stackoverflow.com/questions/5515869/string-length-in-bytes-in-javascript \n "
" */ \n "
"  \n "
" function utf_strlen(text) \n "
" { \n "
"  if(text > 0) \n "
"   text = bytes_to_text(text) \n "
"  var length = text.length \n "
"  var extras = text.match(/%[89ABab]/g); \n "
"  if(extras) \n "
"   length += extras.length \n "
"  return length \n "
" } \n "
"  \n "
" /* \n "
"  Common conversions \n "
" */ \n "
" function file_to_bytes(source) \n "
" { \n "
"  var  \n "
"   fp = NULL, \n "
"   length = 0, \n "
"   data = NULL, \n "
"   packed = source.file,  file = packed || source, \n "
"   error = caught(function(){  \n "
"    fp = fopen(file, 'rb') \n "
"    verify(fp) \n "
"    fseek(fp, 0, SEEK_END) \n "
"    length = ftell(fp) \n "
"    rewind(fp) \n "
"    data = malloc(length + 1) \n "
"    verify(data) \n "
"    verify(length == fread(data, 1, length, fp)) \n "
"    set_byte(data, length, 0) \n "
"    if(packed) \n "
"    {  \n "
"     source.length = length \n "
"     source.bytes = data    data = source \n "
"    } \n "
"   }) \n "
"  if(error) \n "
"  { \n "
"   free(data) \n "
"   data = packed ? null : NULL \n "
"  } \n "
"  if(fp)  fclose(fp) \n "
"  return data \n "
" } \n "
"  \n "
" function bytes_to_file(bytes, file, len) \n "
" { \n "
"  if(bytes == NULL) \n "
"   return false \n "
"  var out = file \n "
"  if(!(file > 0)) \n "
"   out = fopen(file, 'wb+') \n "
"  if(!len) \n "
"   len = utf_strlen(bytes) \n "
"  var pass = false \n "
"  if(out) \n "
"  { \n "
"   if(fwrite(bytes, 1, len, out) == len) \n "
"    pass = true \n "
"   fclose(out) \n "
"  } \n "
"  return pass \n "
" } \n "
"  \n "
" function file_to_text(file) \n "
" { \n "
"  var source = file_to_bytes({ file : file }) \n "
"  if(source == null) \n "
"   return null \n "
"  var  \n "
"   bytes = source.bytes,  result = bytes_to_text(bytes, source.length) \n "
"  free(bytes) \n "
"  return result \n "
" } \n "
"  \n "
" function text_to_file(text, file) \n "
" { \n "
"  var data = text_to_bytes(text) \n "
"  var pass = bytes_to_file(data, file, utf_strlen(data)) free(data) \n "
"  return pass \n "
" } \n "
"  \n "
" /* \n "
"  Conversions to Javascript objects \n "
" */ \n "
" function text_to_function(script, imports) \n "
" { \n "
"  if(!script) \n "
"   return null \n "
"  var hash = char(\"#\"),   bang = char(\"!\"), \n "
"   idx = 0,  \n "
"   len = script.length \n "
"  while(idx < len && isspace(char(script, idx))) \n "
"   ++idx if(len - idx >= 2) \n "
"  { \n "
"   if \n "
"   ( \n "
"    char(script, idx) == hash &&  \n "
"    char(script, idx + 1) == bang \n "
"   ) \n "
"    script = \"//\" + script \n "
"  } \n "
"  var result = null \n "
"  contain(function(){ \n "
"   var bundled =  \n "
"    'return function(){' +  \n "
"    ' var module = { exports : null };' + \n "
"    ' var exports = (function(){' + \n "
"    script +  \n "
"    '})(); return exports ? exports : module.exports }' \n "
"   var invoke = new Function('imports', bundled) \n "
"   result = invoke(imports) \n "
"  }) \n "
"  return result \n "
" } \n "
"  \n "
" function text_to_task(script, imports) \n "
" { \n "
"  var loaded = text_to_function(script, imports); \n "
"  if(loaded) \n "
"   loaded() \n "
"  else \n "
"   return false \n "
"  return true \n "
" } \n "
"  \n "
" function text_to_module(script, imports) \n "
" { \n "
"  var loaded = text_to_function(script, imports); \n "
"  return loaded ? loaded() : null \n "
" } \n "
"  \n "
" function text_to_object(script, imports) \n "
" { \n "
"  return text_to_module('return ' + script, imports) \n "
" } \n "
"  \n "
" function file_to_function(script, imports) \n "
" { \n "
"  return text_to_function(file_to_text(file), imports) \n "
" } \n "
"  \n "
" function file_to_task(file, imports) \n "
" { \n "
"  return text_to_task(file_to_text(file), imports) \n "
" } \n "
"  \n "
" function file_to_module(file, imports) \n "
" { \n "
"  return text_to_module(file_to_text(file), imports) \n "
" } \n "
"  \n "
" function file_to_object(file) \n "
" { \n "
"  return text_to_object(file_to_text(file), imports) \n "
" } \n "
"  \n "
" /* FIXME */ \n "
" /* \n "
" function object_to_text(object) \n "
" { \n "
"  var flg = false, dsc = \"{\" \n "
"  for(var key in object) { \n "
"   if(flg) \n "
"    dsc += \",\" \n "
"   else \n "
"    flg = true \n "
"   dsc += \"\n\"   \n "
"   var mem = object[key]  if(typeof(mem) === \"string\") \n "
"    mem = \"'\" + mem + \"'\" \n "
"   dsc += \" \" + key + \" : \" + mem \n "
"  } \n "
"  dsc += \"\n}\" \n "
"  return dsc \n "
" } \n "
"  \n "
" function object_to_file(object, file) \n "
" { \n "
"  return text_to_file(object_to_text(object), file) \n "
" } \n "
" */ \n "
"  \n "
" /* \n "
"  Input and output \n "
" */ \n "
"  \n "
" function log_display(stream) \n "
" { \n "
"  var args = arguments \n "
"  var first = 1 \n "
"  for(var index = first; index < args.length; ++index) \n "
"  { \n "
"   if(index > first) \n "
"    clog(stream, ' ') \n "
"   var arg = args[index]; \n "
"   if(arg === null) \n "
"    arg = '(null)' \n "
"   else if(arg === undefined) \n "
"    arg = '(undefined)' \n "
"   clog(stream, arg.toString()) \n "
"  } \n "
" } \n "
"  \n "
" function log_print() \n "
" { \n "
"  log_display.apply(null, arguments) \n "
"  putchar(0xa) \n "
" } \n "
"  \n "
" function display() \n "
" { \n "
"  [].unshift.call(arguments, stdout) \n "
"  log_display.apply(null, arguments) \n "
" } \n "
"  \n "
" function print() \n "
" { \n "
"  [].unshift.call(arguments, stdout) \n "
"  log_print.apply(null, arguments) \n "
" } \n "
"  \n "
" function read_line(stream) \n "
" { \n "
"  if(!stream) \n "
"   stream = stdin \n "
"  var newline = 0xa, \n "
"   res = \"\", \n "
"   max = 32,  \n "
"   siz = max + 1,  \n "
"   buf = read_line.buf \n "
"  if(!buf) \n "
"   buf = read_line.buf = malloc(siz) \n "
"  while(true) \n "
"  { \n "
"   if(!fgets(buf, siz, stream)) \n "
"    return res.length == 0 ? null : res \n "
"   var len = strlen(buf), lst = len ? len - 1 : 0  \n "
"   if(get_byte(buf, lst) == newline) \n "
"    set_byte(buf, len = lst, 0) \n "
"   res += bytes_to_text(buf) \n "
"   if(len != max) \n "
"    return res \n "
"  } \n "
" } \n "
"  \n "
" function prompt() \n "
" { \n "
"  display.apply(null, arguments) \n "
"  clog(stdout, ' ') \n "
"  return read_line() \n "
" } \n "
"  \n "
" function script_arguments(skip_first) \n "
" { \n "
"  var args = argv() \n "
"  if(args == NULL) \n "
"   return null \n "
"  var tab = [] \n "
"  if(get_memory(args) == NULL) \n "
"   return tab \n "
"  var align = sizeof('void*') \n "
"  if(skip_first !== false) \n "
"   args += align \n "
"  for(;;) \n "
"  { \n "
"   var ptr = get_memory(args) \n "
"   if(ptr == NULL) \n "
"    break \n "
"   tab.push(bytes_to_text(ptr)) \n "
"   args += align \n "
"  } \n "
"  return tab \n "
" } \n "
"  \n "
" function script_environment() \n "
" { \n "
"  var args = envp() \n "
"  var tab = [] \n "
"  if(args == NULL) \n "
"   return null \n "
"  var align = sizeof('void*') \n "
"  for(;;) \n "
"  { \n "
"   var ptr = get_memory(args) \n "
"   if(ptr == NULL) \n "
"    break \n "
"   tab.push(bytes_to_text(ptr)) \n "
"   args += align \n "
"  } \n "
"  return tab \n "
" } \n "
"  \n "
" function script_path() \n "
" { \n "
"  var args = argv() \n "
"  if(!args) \n "
"   return null \n "
"  return bytes_to_text(get_memory(args)) \n "
" } \n "
"  \n "
" function process_directory(directory, callback) \n "
" { \n "
"  var enter = callback.enter \n "
"  var process = callback.process || callback \n "
"  var leave = callback.leave \n "
"  var saved = current_directory() \n "
"  var handle = opendir(directory) \n "
"  if(handle != NULL) \n "
"  { \n "
"   if(enter) \n "
"    enter(directory) \n "
"   chdir(directory) \n "
"   while(true) \n "
"   { \n "
"    var info = readdir(handle) \n "
"    if(info == NULL) \n "
"     break \n "
"    var path = dirent_name(info) \n "
"    if(path == \".\" || path == \"..\") \n "
"     continue \n "
"    var type = dirent_type(info) \n "
"    if(type & DT_DIR) \n "
"     process_directory(path, callback) \n "
"    else    process(path, type)  \n "
"   }  \n "
"   if(leave) \n "
"    leave(directory) \n "
"   closedir(handle) \n "
"  } \n "
"  chdir(saved) \n "
" } \n "
